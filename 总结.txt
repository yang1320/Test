	计算时涉及到数字精度及数字累计计算时：
		首先依据数学逻辑进行优化。先总再分（先乘再除，先加再减）。（变量不会实际存储无限小数，应该进行了截取存储，所以导致使用存储后的数字进行计算对累计结果产生了误差）
	

	//封装类的使用导致基本类型小给大范围赋值出错！产生类型不兼容。	
	
	
	
	//对象是否相等：是否是同一个引用地址。 引用地址 hashCode()一一对应。（that equal objects must have equal hash codes.）
	
	
	//对象的实际类型由赋予的类型决定而不是申明的类型;编译时对应的申明类型，使用时（程序运行时）使用的是赋予的类型。
	泛型的约束，是由编译时(申明阶段)确定而不是运行时。	？
	
	
	// 基本类型可以自动转换，封装类型不会进行自动转换  		int a='a'; √    Integer c='a'; ×
		//Arrays.asList产生的list对象会使用底层的数组作为其物理实现。
		//	进行涉及集合的操作时，基本类型最好使用其封装类型
	
序列化：
	序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。
	Redis对象读写：字节流作中介，由对象操作流读或写对象（对象需实现序列化，当对象转化为字节数组时会有序列化体现）
	
java里为什么只有汉字（或非西文字符）出现乱码，而英文不会乱码？
	因为西文字符都在前面，字符集很小，所以编码都一样。
	而中文字符集就好几个，几个字符集中同一个汉字对应的编码可能不一样，所以在你选择错了码制的时候，
	就有可能跳到“乱码”所在的索引上了，于是就出现“乱码”了。其实“乱码”的字符也都是正常的字符，只不过出现在不应该出现的地方，组合在一起看起来就乱了。
	UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，
	并使编码无国界，这样就可以显示全世界上所有文化的字符了。
	字符串本身无指定编码格式；使用文字前提是使用的编码包含该文字： 如：ISO8859-1 不包含中文